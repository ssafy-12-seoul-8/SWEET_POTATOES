# 배열의 심화 이해

## 메모리 할당과 배열의 특성

### 연속적인 메모리 할당
- 배열은 물리적으로 연속된 공간에 저장됨. 따라서 물리적 저장 순서와 논리적 저장 순서가 일치함.
- 같은 이유로 인덱스를 기준으로 접근하는 속도가 매우 빠름.

### 인덱스 계산
- 배열에서 i번째 요소에 접근하려면, 배열의 시작 주소에 i번째 요소의 크기만큼을 더하면 됨.
- 이를 통해 O(1) 시간 복잡도로 요소에 접근할 수 있음.

## 배열의 시간 복잡도 분석

### 접근 (Access)
- 인덱스를 알고 있는 경우, 배열의 특정 요소에 접근하는 시간 복잡도는 O(1)
- 이는 배열의 가장 큰 장점 중 하나로, 메모리 주소 계산을 통해 즉시 접근이 가능.

### 탐색 (Search)
- 배열에서 특정 값을 찾기 위해서는 모든 요소를 순차적으로 비교해야 함.
- 선형 탐색(Linear Search)의 경우, 최악의 시간 복잡도는 O(n)
- 이진 탐색(Binary Search)은 배열이 정렬되어 있는 경우에만 사용할 수 있으며, 시간 복잡도는 O(log n)

### 삽입 (Insertion)
- **배열 끝에 삽입**: 배열의 마지막에 요소를 추가하는 경우, 단순히 끝에 추가하면 되므로 시간 복잡도는 O(1)
- **중간 또는 처음에 삽입**: 중간 또는 처음에 삽입하려면, 삽입 위치 이후의 모든 요소를 한 칸씩 뒤로 이동해야 함. 이로 인해 최악의 경우 시간 복잡도는 O(n)

### 삭제 (Deletion) : 삽입과 같음
- **배열 끝에서 삭제**: 마지막 요소를 삭제하는 경우, 단순히 그 요소를 제거하면 되므로 시간 복잡도는 O(1)
- **중간 또는 처음에서 삭제**: 중간 또는 처음의 요소를 삭제하려면, 삭제된 요소 이후의 모든 요소를 한 칸씩 앞으로 이동해야 함. 이 과정에서 최악의 경우 시간 복잡도는 O(n)

## 배열의 장단점

### 장점
- **캐시 지역성(Cache Locality)**: 배열은 메모리의 연속적인 공간을 사용하므로, CPU의 캐시 메모리에 적중할 확률이 높음. 이는 배열의 데이터 접근 속도를 빠르게 하는 중요한 요인 중 하나임.
- **단순성**: 배열은 가장 기본적인 자료구조로, 구현이 간단하고 직관적임. 또한, 메모리 오버헤드가 적어 효율적으로 메모리를 사용할 수 있음.

### 단점
- **고정된 크기**: 배열의 크기는 선언 시 고정되며, 실행 중에 크기를 변경할 수 없음. 이는 프로그램이 배열의 크기를 미리 예측해야 하는 불편함을 초래함.
- **비효율적인 삽입/삭제**: 배열의 연속적인 구조로 인해, 삽입과 삭제 작업이 비효율적. 특히, 배열의 중간에 요소를 삽입하거나 삭제할 때 많은 요소를 이동해야 하기 때문에 성능 저하가 발생할 수 있음.


## 배열과 다른 자료구조와의 비교


### 연결 리스트(Linked List)와 비교
- **메모리 효율성**: 배열은 요소들이 연속된 메모리에 저장되지만, 연결 리스트는 요소들이 포인터를 통해 연결됨. 연결 리스트는 메모리 오버헤드가 더 크지만, 동적 크기 조정과 삽입/삭제 작업이 더 효율적.
- **접근 속도**: 배열은 임의 접근(Random Access)이 가능하지만, 연결 리스트는 순차 접근만 가능함. 즉, 연결 리스트에서 특정 인덱스에 접근하려면 처음부터 해당 인덱스까지 순차적으로 탐색해야 하므로 접근 시간 복잡도는 O(n)

### 동적 배열(Dynamic Array, 예: ArrayList)와 비교
- **동적 크기 조정**: 동적 배열은 크기를 동적으로 조정할 수 있음. 배열이 가득 차면 더 큰 배열로 복사하고, 복사된 배열에 새로운 요소를 추가. 이로 인해 동적 배열은 배열의 단점을 보완하지만, 배열 크기 조정 시 복사 비용이 발생할 수 있음.
- **성능**: 동적 배열은 크기 조정이 일어나지 않는 한 일반 배열과 같은 성능을 가짐. 하지만, 크기 조정이 발생하면 그 순간의 삽입 시간 복잡도는 O(n)이 될 수 있음.

## 배열의 활용 예제

- **정렬된 데이터 저장**: 배열은 정렬된 데이터를 저장하고 빠르게 검색해야 하는 상황에서 유용함. 예를 들어, 이진 탐색 트리에서 데이터를 검색할 때 배열을 사용하면 O(log n) 시간 복잡도로 검색이 가능(효율적)
- **스택(Stack)과 큐(Queue) 구현**: 배열은 스택이나 큐와 같은 선형 자료구조를 구현하는 데 사용될 수 있음. 스택은 배열의 끝을 이용하여 푸시(push)와 팝(pop) 연산을 수행하며, 큐는 배열의 앞과 뒤를 이용해 요소를 삽입 및 삭제할 수 있음.


### 캐시 메모리(Cache Memory)란?
- 캐시 메모리는 CPU와 메인 메모리(RAM) 사이에 위치한 고속의 소형 메모리. CPU는 데이터와 명령어를 매우 빠르게 처리하지만, 메인 메모리의 속도는 상대적으로 느림. 따라서, CPU와 메모리 간의 속도 차이를 줄이기 위해 캐시 메모리가 사용됨.

- 캐시 메모리는 CPU가 자주 사용하는 데이터를 저장해 두는 공간으로, CPU는 필요한 데이터를 메인 메모리에서 직접 가져오기 전에 캐시 메모리에서 먼저 찾음. 만약 캐시 메모리에 해당 데이터가 존재하면(CPU 캐시 히트), CPU는 빠르게 그 데이터를 읽어들여 연산을 수행할 수 있음. 그렇지 않으면(CPU 캐시 미스), 메인 메모리에서 데이터를 가져와야 하므로 속도가 느려짐.

- 캐시 메모리는 자바 뿐만 아니라 모든 프로그래밍 언어로 작성된 프로그램이 실행될 때 작동함.

### 캐시 지역성(Cache Locality)이란?
- 캐시 지역성은 프로그램이 실행될 때 메모리 접근 패턴에 따라 캐시 메모리를 효율적으로 사용하는 성질을 의미함. 캐시 지역성에는 크게 두 가지가 있음 :

1. 공간 지역성(Spatial Locality): 프로그램이 특정 메모리 위치를 참조할 때, 그 근처의 메모리 위치도 곧 참조될 가능성이 높다는 성질. 예를 들어, 배열에서 연속적인 요소에 접근하는 경우, 공간 지역성이 높다고 할 수 있음.

2. 시간 지역성(Temporal Locality): 프로그램이 한 번 참조한 메모리 위치를 곧 다시 참조할 가능성이 높다는 성질. 예를 들어, 반복문에서 동일한 변수를 여러 번 사용하는 경우, 시간 지역성이 높다고 할 수 있음.


## 추가 정보 

### 예측(Prediction)

- 컴퓨터의 실행 속도를 빠르게 하는 방법으로, 프로그램의 동작을 미리 예측할 수 있게 도와주는 방법이 있음.

  1. **분기 예측 (Branch Prediction)**: `if`, `switch` 등의 조건문을 만나면 어떤 경로로 실행될지 예측함. 히스토리 기반 예측, 고정 예측, 다이나믹 예측 등이 있음.

  2. **데이터 프리패칭 (Data Prefetching)**: CPU가 앞으로 사용할 가능성이 높은 데이터를 미리 캐시 메모리에 가져다 놓음. 캐시 지역성과 관련도가 높음.

  3. **캐시 지역성 (Cache Locality)**: 배열과 같은 구조에서 데이터를 순차적으로 접근할 때, CPU가 행동을 예측하고 캐시에 저장해 둠.

  4. **지연 평가 (Lazy Evaluation) 및 미리 계산 (Eager Evaluation)**: 프로그램에서 특정 연산을 미리 해두거나, 필요할 때까지 연산을 미루는 기법.
