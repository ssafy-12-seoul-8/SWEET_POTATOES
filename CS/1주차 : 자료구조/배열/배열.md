# 배열의 심화 이해

## 메모리 할당과 배열의 특성

### 연속적인 메모리 할당
- 배열은 메모리의 연속된 공간에 저장됩니다. 이는 배열이 물리적 저장 순서와 논리적 저장 순서가 일치하는 이유입니다.
- 메모리에서 연속된 위치에 저장되기 때문에, 배열의 첫 번째 요소의 주소를 기준으로 인덱스를 통해 다른 요소들의 위치를 쉽게 계산할 수 있습니다.

### 인덱스 계산
- 배열에서 i번째 요소에 접근하려면, 배열의 시작 주소에 i번째 요소의 크기만큼을 더하면 됩니다.
- 이를 통해 O(1) 시간 복잡도로 요소에 접근할 수 있습니다.

## 배열의 시간 복잡도 분석

### 접근 (Access)
- 인덱스를 알고 있는 경우, 배열의 특정 요소에 접근하는 시간 복잡도는 O(1)입니다.
- 이는 배열의 가장 큰 장점 중 하나로, 메모리 주소 계산을 통해 즉시 접근이 가능하기 때문입니다.

### 탐색 (Search)
- 배열에서 특정 값을 찾기 위해서는 모든 요소를 순차적으로 비교해야 합니다.
- 선형 탐색(Linear Search)의 경우, 최악의 시간 복잡도는 O(n)입니다.
- 이진 탐색(Binary Search)은 배열이 정렬되어 있는 경우에만 사용할 수 있으며, 시간 복잡도는 O(log n)입니다.

### 삽입 (Insertion)
- **배열 끝에 삽입**: 배열의 마지막에 요소를 추가하는 경우, 단순히 끝에 추가하면 되므로 시간 복잡도는 O(1)입니다.
- **중간 또는 처음에 삽입**: 중간 또는 처음에 삽입하려면, 삽입 위치 이후의 모든 요소를 한 칸씩 뒤로 이동해야 합니다. 이로 인해 최악의 경우 시간 복잡도는 O(n)이 됩니다.

### 삭제 (Deletion)
- **배열 끝에서 삭제**: 마지막 요소를 삭제하는 경우, 단순히 그 요소를 제거하면 되므로 시간 복잡도는 O(1)입니다.
- **중간 또는 처음에서 삭제**: 중간 또는 처음의 요소를 삭제하려면, 삭제된 요소 이후의 모든 요소를 한 칸씩 앞으로 이동해야 합니다. 이 과정에서 최악의 경우 시간 복잡도는 O(n)이 됩니다.

## 배열의 장단점 심화

### 장점
- **캐시 지역성(Cache Locality)**: 배열은 메모리의 연속적인 공간을 사용하므로, CPU의 캐시 메모리에 적중할 확률이 높습니다. 이는 배열의 데이터 접근 속도를 빠르게 하는 중요한 요인 중 하나입니다.
- **단순성**: 배열은 가장 기본적인 자료구조로, 구현이 간단하고 직관적입니다. 또한, 메모리 오버헤드가 적어 효율적으로 메모리를 사용할 수 있습니다.

### 단점
- **고정된 크기**: 배열의 크기는 선언 시 고정되며, 실행 중에 크기를 변경할 수 없습니다. 이는 프로그램이 배열의 크기를 미리 예측해야 하는 불편함을 초래합니다.
- **비효율적인 삽입/삭제**: 배열의 연속적인 구조로 인해, 삽입과 삭제 작업이 비효율적입니다. 특히, 배열의 중간에 요소를 삽입하거나 삭제할 때 많은 요소를 이동해야 하기 때문에 성능 저하가 발생할 수 있습니다.

## 배열과 다른 자료구조와의 비교

### 연결 리스트(Linked List)와 비교
- **메모리 효율성**: 배열은 요소들이 연속된 메모리에 저장되지만, 연결 리스트는 요소들이 포인터를 통해 연결됩니다. 연결 리스트는 메모리 오버헤드가 더 크지만, 동적 크기 조정과 삽입/삭제 작업이 더 효율적입니다.
- **접근 속도**: 배열은 임의 접근(Random Access)이 가능하지만, 연결 리스트는 순차 접근만 가능합니다. 즉, 연결 리스트에서 특정 인덱스에 접근하려면 처음부터 해당 인덱스까지 순차적으로 탐색해야 하므로 접근 시간 복잡도는 O(n)입니다.

### 동적 배열(Dynamic Array, 예: ArrayList)와 비교
- **동적 크기 조정**: 동적 배열은 크기를 동적으로 조정할 수 있습니다. 배열이 가득 차면 더 큰 배열로 복사하고, 복사된 배열에 새로운 요소를 추가합니다. 이로 인해 동적 배열은 배열의 단점을 보완하지만, 배열 크기 조정 시 복사 비용이 발생할 수 있습니다.
- **성능**: 동적 배열은 크기 조정이 일어나지 않는 한 일반 배열과 같은 성능을 가집니다. 하지만, 크기 조정이 발생하면 그 순간의 삽입 시간 복잡도는 O(n)이 될 수 있습니다.

## 배열의 활용 예제

- **정렬된 데이터 저장**: 배열은 정렬된 데이터를 저장하고 빠르게 검색해야 하는 상황에서 유용합니다. 예를 들어, 이진 탐색 트리에서 데이터를 검색할 때 배열을 사용하면 O(log n) 시간 복잡도로 검색이 가능합니다.
- **스택(Stack)과 큐(Queue) 구현**: 배열은 스택이나 큐와 같은 선형 자료구조를 구현하는 데 사용될 수 있습니다. 스택은 배열의 끝을 이용하여 푸시(push)와 팝(pop) 연산을 수행하며, 큐는 배열의 앞과 뒤를 이용해 요소를 삽입 및 삭제할 수 있습니다.
